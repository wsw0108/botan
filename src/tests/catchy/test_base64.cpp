// (C) 2015 Simon Warta (Kullo GmbH)
// Botan is released under the Simplified BSD License (see license.txt)

#include "catchy_tests.h"

#if defined(BOTAN_HAS_BASE64_CODEC)

#include <botan/base64.h>

namespace {
std::vector<Botan::byte> toStdVector(const Botan::secure_vector<Botan::byte> &in)
   {
   return std::vector<Botan::byte>(in.cbegin(), in.cend());
   }

std::vector<Botan::byte> toStdVector(const std::string &in)
   {
   return std::vector<Botan::byte>(in.cbegin(), in.cend());
   }
}

TEST_CASE("Base64 encode empty string", "[base64]")
   {
   // common knowledge
   auto emptyString = std::string("");
   auto emptyVector = std::vector<Botan::byte>(emptyString.cbegin(), emptyString.cend());
   CHECK_THAT(Botan::base64_encode(emptyVector), Equals(""));
   }

TEST_CASE("Base64 encode short string", "[base64]")
   {
   // test vectors from http://tools.ietf.org/html/rfc4648
   auto in1 = std::vector<Botan::byte>{ 'f' };
   auto in2 = std::vector<Botan::byte>{ 'f', 'o' };
   auto in3 = std::vector<Botan::byte>{ 'f', 'o', 'o' };
   CHECK_THAT(Botan::base64_encode(in1), Equals("Zg=="));
   CHECK_THAT(Botan::base64_encode(in2), Equals("Zm8="));
   CHECK_THAT(Botan::base64_encode(in3), Equals("Zm9v"));
   }

TEST_CASE("Base64 encode string", "[base64]")
   {
   // Generated by: echo -n "xyz" | base64
   auto in1 = std::vector<Botan::byte>{ 'h','e','l','l','o',' ','w','o','r','l','d' };
   auto in2 = std::vector<Botan::byte>{ 'h','e','l','l','o',' ','w','o','r','l','d','!' };
   auto in3 = std::vector<Botan::byte>{ 'H','e','l','l','o',',',' ','w','o','r','l','d','.' };
   auto in4 = std::vector<Botan::byte>{ 'T','h','e',' ','1','2',' ','c','h','a','r','s' };
   auto in5 = std::vector<Botan::byte>{ 'T','h','e',' ','1','3',' ','c','h','a','r','s','.' };
   auto in6 = std::vector<Botan::byte>{ 'T','h','e',' ','1','4',' ','c','h','a','r','s','.','.' };
   auto in7 = std::vector<Botan::byte>{ 'T','h','e',' ','1','5',' ','c','h','a','r','s','.','.','.' };
   CHECK_THAT(Botan::base64_encode(in1), Equals("aGVsbG8gd29ybGQ="));
   CHECK_THAT(Botan::base64_encode(in2), Equals("aGVsbG8gd29ybGQh"));
   CHECK_THAT(Botan::base64_encode(in3), Equals("SGVsbG8sIHdvcmxkLg=="));
   CHECK_THAT(Botan::base64_encode(in4), Equals("VGhlIDEyIGNoYXJz"));
   CHECK_THAT(Botan::base64_encode(in5), Equals("VGhlIDEzIGNoYXJzLg=="));
   CHECK_THAT(Botan::base64_encode(in6), Equals("VGhlIDE0IGNoYXJzLi4="));
   CHECK_THAT(Botan::base64_encode(in7), Equals("VGhlIDE1IGNoYXJzLi4u"));
   }

TEST_CASE("Base64 encode string special chars", "[base64]")
   {
   // Generated by: echo -n "xyz" | base64
   auto in1 = toStdVector("An UTF-8 uuml: ü");
   auto in2 = toStdVector("Weird German 2 byte thing: ß.");
   CHECK_THAT(Botan::base64_encode(in1), Equals("QW4gVVRGLTggdXVtbDogw7w="));
   CHECK_THAT(Botan::base64_encode(in2), Equals("V2VpcmQgR2VybWFuIDIgYnl0ZSB0aGluZzogw58u"));
   }

TEST_CASE("Base64 encode empty binary", "[base64]")
   {
   auto binary0 = std::vector<unsigned char>{};
   CHECK_THAT(Botan::base64_encode(binary0), Equals(""));
   }

TEST_CASE("Base64 encode binary", "[base64]")
   {
   // Generated by: cat /dev/urandom | head -c 3 | tee /tmp/mybinary | hexdump -C && cat /tmp/mybinary | base64
   std::vector<unsigned char> binary1 = {0x9b};
   CHECK_THAT(Botan::base64_encode(binary1), Equals("mw=="));

   std::vector<unsigned char> binary2 = {0x1c, 0x60};
   CHECK_THAT(Botan::base64_encode(binary2), Equals("HGA="));

   std::vector<unsigned char> binary3 = {0x81, 0x34, 0xbd};
   CHECK_THAT(Botan::base64_encode(binary3), Equals("gTS9"));

   std::vector<unsigned char> binary4 = {0x5e, 0x6c, 0xff, 0xde};
   CHECK_THAT(Botan::base64_encode(binary4), Equals("Xmz/3g=="));

   std::vector<unsigned char> binary5 = {0xb2, 0xcd, 0xf0, 0xdc, 0x7f};
   CHECK_THAT(Botan::base64_encode(binary5), Equals("ss3w3H8="));

   std::vector<unsigned char> binary6 = {0xfc, 0x56, 0x2d, 0xda, 0xd4, 0x0e};
   CHECK_THAT(Botan::base64_encode(binary6), Equals("/FYt2tQO"));

   std::vector<unsigned char> binary7 = {0x29, 0xb2, 0x32, 0x2e, 0x88, 0x41, 0xe8};
   CHECK_THAT(Botan::base64_encode(binary7), Equals("KbIyLohB6A=="));

   std::vector<unsigned char> binary8 = {0x0f, 0x0f, 0xce, 0xd9, 0x49, 0x7a, 0xaf, 0x92};
   CHECK_THAT(Botan::base64_encode(binary8), Equals("Dw/O2Ul6r5I="));

   std::vector<unsigned char> binary9 = {0x27, 0x0f, 0xb1, 0x89, 0x82, 0x80, 0x0d, 0xa6, 0x40};
   CHECK_THAT(Botan::base64_encode(binary9), Equals("Jw+xiYKADaZA"));
   }

TEST_CASE("Base64 decode empty string", "[base64]")
   {
   // common knowledge
   auto outVector = toStdVector(Botan::base64_decode(""));
   CHECK_THAT(outVector, Equals(std::vector<Botan::byte>{}));
   }

TEST_CASE("Base64 decode short string", "[base64]")
   {
   // test vectors from http://tools.ietf.org/html/rfc4648
   CHECK_THAT(toStdVector(Botan::base64_decode("Zg==")), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode("Zm8=")), Equals(toStdVector("fo")));
   CHECK_THAT(toStdVector(Botan::base64_decode("Zm9v")), Equals(toStdVector("foo")));
   }

TEST_CASE("Base64 decode string", "[base64]")
   {
   // Generated by: echo -n "xyz" | base64
   CHECK_THAT(toStdVector(Botan::base64_decode("aGVsbG8gd29ybGQ=")),     Equals(toStdVector("hello world")));
   CHECK_THAT(toStdVector(Botan::base64_decode("aGVsbG8gd29ybGQh")),     Equals(toStdVector("hello world!")));
   CHECK_THAT(toStdVector(Botan::base64_decode("SGVsbG8sIHdvcmxkLg==")), Equals(toStdVector("Hello, world.")));
   CHECK_THAT(toStdVector(Botan::base64_decode("VGhlIDEyIGNoYXJz")),     Equals(toStdVector("The 12 chars")));
   CHECK_THAT(toStdVector(Botan::base64_decode("VGhlIDEzIGNoYXJzLg==")), Equals(toStdVector("The 13 chars.")));
   CHECK_THAT(toStdVector(Botan::base64_decode("VGhlIDE0IGNoYXJzLi4=")), Equals(toStdVector("The 14 chars..")));
   CHECK_THAT(toStdVector(Botan::base64_decode("VGhlIDE1IGNoYXJzLi4u")), Equals(toStdVector("The 15 chars...")));
   }

TEST_CASE("Base64 decode string special chars", "[base64]")
   {
   // Generated by: echo -n "xyz" | base64
   auto in1 = std::string("QW4gVVRGLTggdXVtbDogw7w=");
   auto in2 = std::string("V2VpcmQgR2VybWFuIDIgYnl0ZSB0aGluZzogw58u");
   auto out1 = std::string("An UTF-8 uuml: ü");
   auto out2 = std::string("Weird German 2 byte thing: ß.");
   CHECK_THAT(toStdVector(Botan::base64_decode(in1)), Equals(toStdVector(out1)));
   CHECK_THAT(toStdVector(Botan::base64_decode(in2)), Equals(toStdVector(out2)));
   }

TEST_CASE("Base64 decode binary", "[base64]")
   {
   // Generated by: cat /dev/urandom | head -c 3 | tee /tmp/mybinary | hexdump -C && cat /tmp/mybinary | base64
   std::vector<unsigned char> binary0 = {};
   CHECK_THAT(toStdVector(Botan::base64_decode("")), Equals(binary0));

   std::vector<unsigned char> binary1 = {0x9b};
   CHECK_THAT(toStdVector(Botan::base64_decode("mw==")), Equals(binary1));

   std::vector<unsigned char> binary2 = {0x1c, 0x60};
   CHECK_THAT(toStdVector(Botan::base64_decode("HGA=")), Equals(binary2));

   std::vector<unsigned char> binary3 = {0x81, 0x34, 0xbd};
   CHECK_THAT(toStdVector(Botan::base64_decode("gTS9")), Equals(binary3));

   std::vector<unsigned char> binary4 = {0x5e, 0x6c, 0xff, 0xde};
   CHECK_THAT(toStdVector(Botan::base64_decode("Xmz/3g==")), Equals(binary4));

   std::vector<unsigned char> binary5 = {0xb2, 0xcd, 0xf0, 0xdc, 0x7f};
   CHECK_THAT(toStdVector(Botan::base64_decode("ss3w3H8=")), Equals(binary5));

   std::vector<unsigned char> binary6 = {0xfc, 0x56, 0x2d, 0xda, 0xd4, 0x0e};
   CHECK_THAT(toStdVector(Botan::base64_decode("/FYt2tQO")), Equals(binary6));

   std::vector<unsigned char> binary7 = {0x29, 0xb2, 0x32, 0x2e, 0x88, 0x41, 0xe8};
   CHECK_THAT(toStdVector(Botan::base64_decode("KbIyLohB6A==")), Equals(binary7));

   std::vector<unsigned char> binary8 = {0x0f, 0x0f, 0xce, 0xd9, 0x49, 0x7a, 0xaf, 0x92};
   CHECK_THAT(toStdVector(Botan::base64_decode("Dw/O2Ul6r5I=")), Equals(binary8));

   std::vector<unsigned char> binary9 = {0x27, 0x0f, 0xb1, 0x89, 0x82, 0x80, 0x0d, 0xa6, 0x40};
   CHECK_THAT(toStdVector(Botan::base64_decode("Jw+xiYKADaZA")), Equals(binary9));
   }

TEST_CASE("Base64 decode and ignore whitespace", "[base64]")
   {
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string(" Zg=="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Z g=="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg =="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg= ="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg== "), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("\rZg=="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("\nZg=="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("\tZg=="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg\r=="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg\n=="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg\t=="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg==\r"), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg==\n"), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg==\t"), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("\r Zg=="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("\n Zg=="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("\t Zg=="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg\r =="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg\n =="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg\t =="), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg==\r "), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg==\n "), true)), Equals(toStdVector("f")));
   CHECK_THAT(toStdVector(Botan::base64_decode(std::string("Zg==\t "), true)), Equals(toStdVector("f")));
   }

TEST_CASE("Base64 decode and don't ignore whitespace", "[base64]")
   {
   CHECK_THROWS(Botan::base64_decode(std::string(" Zg=="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Z g=="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg =="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg= ="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg== "), false));
   CHECK_THROWS(Botan::base64_decode(std::string("\rZg=="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("\nZg=="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("\tZg=="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg\r=="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg\n=="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg\t=="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg==\r"), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg==\n"), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg==\t"), false));
   CHECK_THROWS(Botan::base64_decode(std::string("\r Zg=="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("\n Zg=="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("\t Zg=="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg\r =="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg\n =="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg\t =="), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg==\r "), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg==\n "), false));
   CHECK_THROWS(Botan::base64_decode(std::string("Zg==\t "), false));
   }

#endif // BOTAN_HAS_BASE64_CODEC
